package config

// Generated by app.quicktype.io from schema https://raw.githubusercontent.com/CircleCI-Public/circleci-yaml-language-server/81d648799b23079df81323610414fedb79a76355/publicschema.json
//
// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse and unparse this JSON data, add this code to your project and do:
//
//    config, err := UnmarshalConfig(bytes)
//    bytes, err = config.Marshal()

import (
	"bytes"
	"encoding/json"
	"errors"
	"reflect"
	"strings"
)

func UnmarshalConfig(data []byte) (Config, error) {
	var r Config
	err := json.Unmarshal(data, &r)
	return r, err
}

func (r *Config) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

type Config struct {
	Commands  map[string]CommandValue  `json:"commands,omitempty"`
	Executors map[string]ExecutorValue `json:"executors,omitempty"`
	Jobs      map[string]JobValue      `json:"jobs,omitempty"`
	Orbs      map[string]*ORBValue     `json:"orbs,omitempty"`
	// The version field is intended to be used in order to issue warnings for deprecation or
	// breaking changes.
	Version *VersionUnion `json:"version"`
	// Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and
	// a map as a value
	Workflows map[string]*WorkflowValue `json:"workflows,omitempty"`
	// A map of parameter keys.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// https://circleci.com/docs/configuration-reference#commands-requires-version-21
//
// Definition of a custom command.
type CommandValue struct {
	// A string that describes the purpose of the command.
	Description *string `json:"description,omitempty"`
	// https://circleci.com/docs/reusing-config#using-the-parameters-declaration
	//
	// A map of parameter keys.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
	// A sequence of steps run inside the calling job of the command.
	Steps []Step `json:"steps"`
}

// https://circleci.com/docs/configuration-reference#the-when-step-requires-version-21
//
// Conditional step to run on custom conditions (determined at config-compile time) that are
// checked before a workflow runs
type WhenClass struct {
	Condition *Logical `json:"condition"`
	// A list of steps to be performed
	Steps ConditionalStepClass `json:"steps"`
}

// https://circleci.com/docs/configuration-reference#the-when-step-requires-version-21
//
// Conditional step to run when custom conditions aren't met (determined at config-compile
// time) that are checked before a workflow runs
type Unless struct {
	Condition *Logical `json:"condition"`
	// A list of steps to be performed
	Steps []Step `json:"steps"`
}

type StepClass struct {
	AddSSHKeys         *AddSSHKeys         `json:"add_ssh_keys,omitempty"`
	AttachWorkspace    *AttachWorkspace    `json:"attach_workspace,omitempty"`
	Checkout           *Checkout           `json:"checkout,omitempty"`
	Deploy             *Deploy             `json:"deploy"`
	PersistToWorkspace *PersistToWorkspace `json:"persist_to_workspace,omitempty"`
	RestoreCache       *RestoreCache       `json:"restore_cache,omitempty"`
	Run                *Deploy             `json:"run"`
	SaveCache          *SaveCache          `json:"save_cache,omitempty"`
	SetupRemoteDocker  *SetupRemoteDocker  `json:"setup_remote_docker,omitempty"`
	StoreArtifacts     *StoreArtifacts     `json:"store_artifacts,omitempty"`
	StoreTestResults   *StoreTestResults   `json:"store_test_results,omitempty"`
	Steps              *string             `json:"steps"`
	Unless             *Unless             `json:"unless,omitempty"`
	When               *WhenClass          `json:"when,omitempty"`
}

type LogicalClass struct {
	// https://circleci.com/docs/configuration-reference#logic-statements
	//
	// Logical and: true when all statements in the list are true
	And []Logical `json:"and,omitempty"`
	// https://circleci.com/docs/configuration-reference#logic-statements
	//
	// True when all elements in the list are equal
	Equal []interface{} `json:"equal,omitempty"`
	// https://circleci.com/docs/configuration-reference#logic-statements
	//
	// True when value matches the pattern
	Matches *Matches `json:"matches,omitempty"`
	// https://circleci.com/docs/configuration-reference#logic-statements
	//
	// Logical not: true when statement is false
	Not *Logical `json:"not"`
	// https://circleci.com/docs/configuration-reference#logic-statements
	//
	// Logical or: true when at least one statements in the list is true
	Or []Logical `json:"or,omitempty"`
}

// https://circleci.com/docs/configuration-reference#logic-statements
//
// True when value matches the pattern
type Matches struct {
	Pattern *string `json:"pattern,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// https://circleci.com/docs/configuration-reference#add_ssh_keys
//
// Special step that adds SSH keys from a project’s settings to a container. Also configures
// SSH to use these keys.
type AddSSHKeys struct {
	// Directory to attach the workspace to
	Fingerprints []string `json:"fingerprints,omitempty"`
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
}

// https://circleci.com/docs/configuration-reference#attach_workspace
//
// Special step used to attach the workflow's workspace to the current container. The full
// contents of the workspace are downloaded and copied into the directory the workspace is
// being attached at.
type AttachWorkspace struct {
	// Directory to attach the workspace to
	At string `json:"at"`
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
}

// https://circleci.com/docs/configuration-reference#checkout
//
// Special step used to check out source code to the configured `path` (defaults to the
// `working_directory`). The reason this is a special step is because it is more of a helper
// function designed to make checking out code easy for you. If you require doing git over
// HTTPS you should not use this step as it configures git to checkout over ssh.
type Checkout struct {
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
	// Checkout directory (default: job’s `working_directory`)
	Path *string `json:"path,omitempty"`
}

type Confi struct {
	// Whether or not this step should run in the background (default: false)
	Background *bool `json:"background,omitempty"`
	// Command to run via the shell
	Command string `json:"command"`
	// Additional environmental variables, locally scoped to command
	Environment map[string]*Xcode `json:"environment,omitempty"`
	// Title of the step to be shown in the CircleCI UI (default: full `command`)
	Name *string `json:"name,omitempty"`
	// Elapsed time the command can run without output. The string is a decimal with unit
	// suffix, such as "20m", "1.25h", "5s" (default: 10 minutes)
	NoOutputTimeout *string `json:"no_output_timeout,omitempty"`
	// Shell to use for execution command
	Shell *string `json:"shell,omitempty"`
	// Specify when to enable or disable the step. Takes the following values: `always`,
	// `on_success`, `on_fail` (default: `on_success`)
	When *WhenEnum `json:"when,omitempty"`
	// In which directory to run this step (default: `working_directory` of the job
	WorkingDirectory *string `json:"working_directory,omitempty"`
}

// https://circleci.com/docs/configuration-reference#persist_to_workspace
//
// Special step used to persist a temporary file to be used by another job in the workflow
type PersistToWorkspace struct {
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
	// Glob identifying file(s), or a non-glob path to a directory to add to the shared
	// workspace. Interpreted as relative to the workspace root. Must not be the workspace root
	// itself.
	Paths []string `json:"paths"`
	// Either an absolute path or a path relative to `working_directory`
	Root string `json:"root"`
}

// https://circleci.com/docs/configuration-reference#restore_cache
//
// Restores a previously saved cache based on a `key`. Cache needs to have been saved first
// for this key using the `save_cache` step.
type RestoreCache struct {
	// Single cache key to restore
	Key *string `json:"key,omitempty"`
	// Title of the step to be shown in the CircleCI UI (default: 'Restoring Cache')
	Name *string `json:"name,omitempty"`
	// List of cache keys to lookup for a cache to restore. Only first existing key will be
	// restored.
	Keys []string `json:"keys,omitempty"`
}

// https://circleci.com/docs/configuration-reference#save_cache
//
// Generates and stores a cache of a file or directory of files such as dependencies or
// source code in our object storage. Later jobs can restore this cache using the
// `restore_cache` step.
type SaveCache struct {
	// Unique identifier for this cache
	Key string `json:"key"`
	// Title of the step to be shown in the CircleCI UI (default: 'Saving Cache')
	Name *string `json:"name,omitempty"`
	// List of directories which should be added to the cache
	Paths []string `json:"paths"`
	// Specify when to enable or disable the step. Takes the following values: `always`,
	// `on_success`, `on_fail` (default: `on_success`)
	When *WhenEnum `json:"when,omitempty"`
}

// https://circleci.com/docs/configuration-reference#setup_remote_docker
//
// Creates a remote Docker environment configured to execute Docker commands.
type SetupRemoteDocker struct {
	// When `docker_layer_caching` is set to `true`, CircleCI will try to reuse Docker Images
	// (layers) built during a previous job or workflow (Paid feature)
	DockerLayerCaching *bool `json:"docker_layer_caching,omitempty"`
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
	// If your build requires a specific docker image, you can set it as an image attribute
	Version *VersionEnum `json:"version,omitempty"`
}

// https://circleci.com/docs/configuration-reference#store_artifacts
//
// Step to store artifacts (for example logs, binaries, etc) to be available in the web app
// or through the API.
type StoreArtifacts struct {
	// Prefix added to the artifact paths in the artifacts API (default: the directory of the
	// file specified in `path`)
	Destination *string `json:"destination,omitempty"`
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
	// Directory in the primary container to save as job artifacts
	Path string `json:"path"`
}

// https://circleci.com/docs/configuration-reference#storetestresults
//
// Special step used to upload test results so they display in builds’ Test Summary section
// and can be used for timing analysis. To also see test result as build artifacts, please
// use the `store_artifacts` step.
type StoreTestResults struct {
	// Title of the step to be shown in the CircleCI UI
	Name *string `json:"name,omitempty"`
	// Path (absolute, or relative to your `working_directory`) to directory containing
	// subdirectories of JUnit XML or Cucumber JSON test metadata files
	Path string `json:"path"`
}

type ExecutorValue struct {
	// A map of environment variable names and values.
	Environment map[string]*Xcode `json:"environment,omitempty"`
	// Amount of CPU and RAM allocated to each container in a job. Note: A performance plan is
	// required to access this feature.
	ResourceClass *ResourceClass `json:"resource_class,omitempty"`
	// Shell to use for execution command in all steps. Can be overridden by shell in each step
	// (default: See [Default Shell
	// Options](https://circleci.com/docs/configuration-reference#default-shell-options)
	Shell *string `json:"shell,omitempty"`
	// In which directory to run the steps.
	WorkingDirectory *string          `json:"working_directory,omitempty"`
	Docker           []DockerExecutor `json:"docker,omitempty"`
	// Use the default machine executor image
	Machine *Machine       `json:"machine"`
	Macos   *MacosExecutor `json:"macos,omitempty"`
	// A map of parameter keys.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// Options for the [docker
// executor](https://circleci.com/docs/configuration-reference#docker)
type DockerExecutor struct {
	// Authentication for registries using standard `docker login` credentials
	Auth *Auth `json:"auth,omitempty"`
	// Authentication for AWS EC2 Container Registry (ECR)
	AwsAuth *AwsAuth `json:"aws_auth,omitempty"`
	// The command used as pid 1 (or args for entrypoint) when launching the container
	Command *CommandUnion `json:"command"`
	// The command used as executable when launching the container
	Entrypoint *CommandUnion `json:"entrypoint"`
	// A map of environment variable names and values
	Environment map[string]*Environment `json:"environment,omitempty"`
	// The name of a custom docker image to use
	Image string `json:"image"`
	// The name the container is reachable by. By default, container services are accessible
	// through `localhost`
	Name *string `json:"name,omitempty"`
	// Which user to run the command as
	User *string `json:"user,omitempty"`
}

// Authentication for registries using standard `docker login` credentials
type Auth struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// Authentication for AWS EC2 Container Registry (ECR)
type AwsAuth struct {
	AwsAccessKeyID     *string `json:"aws_access_key_id,omitempty"`
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
}

// Options for the [machine
// executor](https://circleci.com/docs/configuration-reference#machine)
type MachineExecutor struct {
	// Set to `true` to enable [Docker Layer
	// Caching](https://circleci.com/docs/docker-layer-caching). Note: If you haven't already,
	// you must open a support ticket to have a CircleCI Sales representative contact you about
	// enabling this feature on your account for an additional fee.
	DockerLayerCaching *bool `json:"docker_layer_caching,omitempty"`
	// The VM image to use. View [available
	// images](https://circleci.com/docs/configuration-reference#available-machine-images).
	// **Note:** This key is **not** supported on the installable CircleCI. For information
	// about customizing machine executor images on CircleCI installed on your servers, see our
	// [VM Service documentation](https://circleci.com/docs/vm-service).
	Image string `json:"image"`
}

// Options for the [macOS executor](https://circleci.com/docs/configuration-reference#macos)
type MacosExecutor struct {
	// The version of Xcode that is installed on the virtual machine, see the [Supported Xcode
	// Versions section of the Testing
	// iOS](https://circleci.com/docs/testing-ios#supported-xcode-versions) document for the
	// complete list.
	Xcode *Xcode `json:"xcode"`
}

type JobValue struct {
	// A map defining rules for whitelisting/blacklisting execution of specific branches for a
	// single job that is **not** in a workflow (default: all whitelisted). See Workflows for
	// configuring branch execution for jobs in a workflow.
	Branches map[string]string `json:"branches,omitempty"`
	// A map of environment variable names and variables (NOTE: these will override any
	// environment variables you set in the CircleCI web interface).
	Environment map[string]*Xcode `json:"environment,omitempty"`
	// Number of parallel instances of this job to run (default: 1)
	Parallelism *Parallelism `json:"parallelism"`
	// Shell to use for execution command in all steps. Can be overridden by shell in each step
	Shell *string `json:"shell,omitempty"`
	// A list of steps to be performed
	Steps []Step `json:"steps"`
	// In which directory to run the steps. (default: `~/project`. `project` is a literal
	// string, not the name of the project.) You can also refer the directory with
	// `$CIRCLE_WORKING_DIRECTORY` environment variable.
	WorkingDirectory *string          `json:"working_directory,omitempty"`
	Docker           []DockerExecutor `json:"docker,omitempty"`
	// Use the default machine executor image
	Machine *Machine       `json:"machine"`
	Macos   *MacosExecutor `json:"macos,omitempty"`
	// The name of the executor to use (defined via the top level executors map).
	//
	// Executor stanza to use for the job
	Executor *ExecutorUnion `json:"executor"`
	// A map of parameter keys.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// Executor stanza to use for the job
type ExecutorClass struct {
	// The name of the executor to use (defined via the top level executors map).
	Name string `json:"name"`
}

// https://circleci.com/docs/creating-orbs#creating-inline-orbs
//
// Inline orbs can be handy during development of an orb or as a convenience for
// name-spacing jobs and commands in lengthy configurations, particularly if you later
// intend to share the orb with others.
type ORBClass struct {
	Commands  map[string]CommandValue  `json:"commands,omitempty"`
	Executors map[string]ExecutorValue `json:"executors,omitempty"`
	Jobs      map[string]JobValue      `json:"jobs,omitempty"`
	Orbs      map[string]*ORBValue     `json:"orbs,omitempty"`
}

type Workflow struct {
	Jobs []Job `json:"jobs,omitempty"`
	// Specifies which triggers will cause this workflow to be executed. Default behavior is to
	// trigger the workflow when pushing to a branch.
	Triggers []Trigger `json:"triggers,omitempty"`
	// Specify when *not* to run the workflow.
	Unless *Logical `json:"unless"`
	// Specify when to run the workflow.
	When *Logical `json:"when"`
}

// Run a job as part of this workflow
type JobRef struct {
	// Either a single context name, or a list of contexts. The default name is `org-global`
	Context *CommandUnion `json:"context"`
	// A map defining rules for execution on specific branches
	Filters *JobFilters `json:"filters,omitempty"`
	// https://circleci.com/docs/configuration-reference#matrix-requires-version-21
	//
	// The matrix stanza allows you to run a parameterized job multiple times with different
	// arguments.
	Matrix *Matrix `json:"matrix,omitempty"`
	// Jobs are run in parallel by default, so you must explicitly require any dependencies by
	// their job name.
	Requires []string `json:"requires,omitempty"`
	// A job may have a `type` of `approval` indicating it must be manually approved before
	// downstream jobs may proceed.
	Type *Type `json:"type,omitempty"`
}

// A map defining rules for execution on specific branches
type JobFilters struct {
	Branches *Filter `json:"branches,omitempty"`
	Tags     *Filter `json:"tags,omitempty"`
}

// A map defining rules for execution on specific branches
type Filter struct {
	// Either a single branch specifier, or a list of branch specifiers
	Ignore *CommandUnion `json:"ignore"`
	// Either a single branch specifier, or a list of branch specifiers
	Only *CommandUnion `json:"only"`
}

// https://circleci.com/docs/configuration-reference#matrix-requires-version-21
//
// The matrix stanza allows you to run a parameterized job multiple times with different
// arguments.
type Matrix struct {
	// An alias for the matrix, usable from another job’s requires stanza. Defaults to the name
	// of the job being executed
	Alias *string `json:"alias,omitempty"`
	// A list of argument maps that should be excluded from the matrix
	Exclude []map[string]interface{} `json:"exclude,omitempty"`
	// A map of parameter names to every value the job should be called with
	Parameters map[string][]interface{} `json:"parameters"`
}

type Trigger struct {
	// A workflow may have a schedule indicating it runs at a certain time, for example a
	// nightly build that runs every day at 12am UTC:
	Schedule *Schedule `json:"schedule,omitempty"`
}

// A workflow may have a schedule indicating it runs at a certain time, for example a
// nightly build that runs every day at 12am UTC:
type Schedule struct {
	// See the [crontab man page](http://pubs.opengroup.org/onlinepubs/7908799/xcu/crontab.html)
	Cron *string `json:"cron,omitempty"`
	// A map defining rules for execution on specific branches
	Filters *ScheduleFilters `json:"filters,omitempty"`
}

// A map defining rules for execution on specific branches
type ScheduleFilters struct {
	Branches *Filter `json:"branches,omitempty"`
}

// Specify when to enable or disable the step. Takes the following values: `always`,
// `on_success`, `on_fail` (default: `on_success`)
type WhenEnum string

const (
	Always    WhenEnum = "always"
	OnFail    WhenEnum = "on_fail"
	OnSuccess WhenEnum = "on_success"
)

// If your build requires a specific docker image, you can set it as an image attribute
type VersionEnum string

const (
	The17090Ce VersionEnum = "17.09.0-ce"
	The190313  VersionEnum = "19.03.13"
	The201011  VersionEnum = "20.10.11"
	The201012  VersionEnum = "20.10.12"
	The201014  VersionEnum = "20.10.14"
	The20102   VersionEnum = "20.10.2"
	The20106   VersionEnum = "20.10.6"
	The20107   VersionEnum = "20.10.7"
)

// Amount of CPU and RAM allocated to each container in a job. Note: A performance plan is
// required to access this feature.
type ResourceClass string

const (
	GPUNvidiaMedium        ResourceClass = "gpu.nvidia.medium"
	GPUNvidiaSmall         ResourceClass = "gpu.nvidia.small"
	Large                  ResourceClass = "large"
	MacosX86MediumGen2     ResourceClass = "macos.x86.medium.gen2"
	MacosX86MetalGen1      ResourceClass = "macos.x86.metal.gen1"
	Medium                 ResourceClass = "medium"
	ResourceClass2Xlarge   ResourceClass = "2xlarge+"
	ResourceClassMedium    ResourceClass = "medium+"
	Small                  ResourceClass = "small"
	The2Xlarge             ResourceClass = "2xlarge"
	WindowsGPUNvidiaMedium ResourceClass = "windows.gpu.nvidia.medium"
	Xlarge                 ResourceClass = "xlarge"
)

// A job may have a `type` of `approval` indicating it must be manually approved before
// downstream jobs may proceed.
type Type string

const (
	Approval Type = "approval"
)

type Step struct {
	StepClass *StepClass
	String    *string
	MapClass  map[string]map[string]interface{}
}

func (x *Step) UnmarshalJSON(data []byte) error {
	x.StepClass = nil
	var c StepClass
	object, err := unmarshalUnionWithMap(data, nil, nil, nil, &x.String, false, nil, true, &c, false, nil, false, nil, false, listFields(c), &x.MapClass)
	if err != nil {
		return err
	}
	if object {
		x.StepClass = &c
	}
	return nil
}

func (x *Step) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, false, nil, x.StepClass != nil, x.StepClass, false, nil, false, nil, false)
}

// https://circleci.com/docs/configuration-reference#logic-statements
//
// # A logical statement to be used in dynamic configuration
//
// https://circleci.com/docs/configuration-reference#logic-statements
//
// Logical not: true when statement is false
//
// Specify when *not* to run the workflow.
//
// Specify when to run the workflow.
type Logical struct {
	Bool         *bool
	Double       *float64
	Integer      *int64
	LogicalClass *LogicalClass
	String       *string
}

func (x *Logical) UnmarshalJSON(data []byte) error {
	x.LogicalClass = nil
	var c LogicalClass
	object, err := unmarshalUnion(data, &x.Integer, &x.Double, &x.Bool, &x.String, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.LogicalClass = &c
	}
	return nil
}

func (x *Logical) MarshalJSON() ([]byte, error) {
	return marshalUnion(x.Integer, x.Double, x.Bool, x.String, false, nil, x.LogicalClass != nil, x.LogicalClass, false, nil, false, nil, false)
}

// https://circleci.com/docs/configuration-reference#deploy
//
// Special step for deploying artifacts. `deploy` uses the same configuration map and
// semantics as run step. Jobs may have more than one deploy step. In general deploy step
// behaves just like run with two exceptions:
// * In a job with parallelism, the deploy step will only be executed by node #0 and only if
// all nodes succeed. Nodes other than #0 will skip this step.
// * In a job that runs with SSH, the deploy step will not execute
//
// https://circleci.com/docs/configuration-reference#run
//
// Used for invoking all command-line programs, taking either a map of configuration values,
// or, when called in its short-form, a string that will be used as both the `command` and
// `name`. Run commands are executed using non-login shells by default, so you must
// explicitly source any dotfiles as part of the command.
type Deploy struct {
	Confi  *Confi
	String *string
}

func (x *Deploy) UnmarshalJSON(data []byte) error {
	x.Confi = nil
	var c Confi
	object, err := unmarshalUnion(data, nil, nil, nil, &x.String, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.Confi = &c
	}
	return nil
}

func (x *Deploy) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, false, nil, x.Confi != nil, x.Confi, false, nil, false, nil, false)
}

// The version of Xcode that is installed on the virtual machine, see the [Supported Xcode
// Versions section of the Testing
// iOS](https://circleci.com/docs/testing-ios#supported-xcode-versions) document for the
// complete list.
type Xcode struct {
	Double *float64
	String *string
}

func (x *Xcode) UnmarshalJSON(data []byte) error {
	object, err := unmarshalUnion(data, nil, &x.Double, nil, &x.String, false, nil, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *Xcode) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, x.Double, nil, x.String, false, nil, false, nil, false, nil, false, nil, false)
}

// The command used as pid 1 (or args for entrypoint) when launching the container
//
// # The command used as executable when launching the container
//
// Either a single context name, or a list of contexts. The default name is `org-global`
//
// Either a single branch specifier, or a list of branch specifiers
type CommandUnion struct {
	String      *string
	StringArray []string
}

func (x *CommandUnion) UnmarshalJSON(data []byte) error {
	x.StringArray = nil
	object, err := unmarshalUnion(data, nil, nil, nil, &x.String, true, &x.StringArray, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *CommandUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, x.StringArray != nil, x.StringArray, false, nil, false, nil, false, nil, false)
}

type Environment struct {
	Bool   *bool
	Double *float64
	String *string
}

func (x *Environment) UnmarshalJSON(data []byte) error {
	object, err := unmarshalUnion(data, nil, &x.Double, &x.Bool, &x.String, false, nil, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *Environment) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, x.Double, x.Bool, x.String, false, nil, false, nil, false, nil, false, nil, false)
}

type Machine struct {
	Bool            *bool
	MachineExecutor *MachineExecutor
}

func (x *Machine) UnmarshalJSON(data []byte) error {
	x.MachineExecutor = nil
	var c MachineExecutor
	object, err := unmarshalUnion(data, nil, nil, &x.Bool, nil, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.MachineExecutor = &c
	}
	return nil
}

func (x *Machine) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, x.Bool, nil, false, nil, x.MachineExecutor != nil, x.MachineExecutor, false, nil, false, nil, false)
}

type ExecutorUnion struct {
	ExecutorClass *ExecutorClass
	String        *string
	MapClass      map[string]interface{}
}

func (x *ExecutorUnion) UnmarshalJSON(data []byte) error {
	x.ExecutorClass = nil
	_, err := unmarshalUnion(data, nil, nil, nil, &x.String, false, nil, true, &x.MapClass, false, nil, false, nil, false)
	if err != nil {
		return err
	}

	return nil
}

func (x *ExecutorUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, false, nil, x.ExecutorClass != nil, x.ExecutorClass, false, nil, false, nil, false)
}

// Number of parallel instances of this job to run (default: 1)
type Parallelism struct {
	Integer *int64
	String  *string
}

func (x *Parallelism) UnmarshalJSON(data []byte) error {
	object, err := unmarshalUnion(data, &x.Integer, nil, nil, &x.String, false, nil, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *Parallelism) MarshalJSON() ([]byte, error) {
	return marshalUnion(x.Integer, nil, nil, x.String, false, nil, false, nil, false, nil, false, nil, false)
}

type ORBValue struct {
	ORBClass *ORBClass
	String   *string
}

func (x *ORBValue) UnmarshalJSON(data []byte) error {
	x.ORBClass = nil
	var c ORBClass
	object, err := unmarshalUnion(data, nil, nil, nil, &x.String, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.ORBClass = &c
	}
	return nil
}

func (x *ORBValue) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, false, nil, x.ORBClass != nil, x.ORBClass, false, nil, false, nil, false)
}

// The version field is intended to be used in order to issue warnings for deprecation or
// breaking changes.
//
// The Workflows `version` field is used to issue warnings for deprecation or breaking
// changes during v2 Beta. It is deprecated as of CircleCI v2.1
type VersionUnion struct {
	Double  *float64
	Integer *int64
	String  *string
}

func (x *VersionUnion) UnmarshalJSON(data []byte) error {
	object, err := unmarshalUnion(data, &x.Integer, &x.Double, nil, &x.String, false, nil, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *VersionUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(x.Integer, x.Double, nil, nil, false, nil, false, nil, false, nil, false, nil, false)
}

type WorkflowValue struct {
	Double   *float64
	Integer  *int64
	Workflow *Workflow
}

func (x *WorkflowValue) UnmarshalJSON(data []byte) error {
	x.Workflow = nil
	var c Workflow
	object, err := unmarshalUnion(data, &x.Integer, &x.Double, nil, nil, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.Workflow = &c
	}
	return nil
}

func (x *WorkflowValue) MarshalJSON() ([]byte, error) {
	return marshalUnion(x.Integer, x.Double, nil, nil, false, nil, x.Workflow != nil, x.Workflow, false, nil, false, nil, false)
}

type Job struct {
	JobRefMap map[string]JobRef
	String    *string
	MapClass  map[string]map[string]interface{}
}

func (x *Job) UnmarshalJSON(data []byte) error {
	x.JobRefMap = nil
	var a JobRef
	object, err := unmarshalUnionWithMap(data, nil, nil, nil, &x.String, false, nil, false, nil, true, &x.JobRefMap, false, nil, false, listFields(a), &x.MapClass)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *Job) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, x.String, false, nil, false, nil, x.JobRefMap != nil, x.JobRefMap, false, nil, false)
}

func unmarshalUnion(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) (bool, error) {
	if pi != nil {
		*pi = nil
	}
	if pf != nil {
		*pf = nil
	}
	if pb != nil {
		*pb = nil
	}
	if ps != nil {
		*ps = nil
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.UseNumber()
	tok, err := dec.Token()
	if err != nil {
		return false, err
	}

	switch v := tok.(type) {
	case json.Number:
		if pi != nil {
			i, err := v.Int64()
			if err == nil {
				*pi = &i
				return false, nil
			}
		}
		if pf != nil {
			f, err := v.Float64()
			if err == nil {
				*pf = &f
				return false, nil
			}
			return false, errors.New("Unparsable number")
		}
		return false, errors.New("Union does not contain number")
	case float64:
		return false, errors.New("Decoder should not return float64")
	case bool:
		if pb != nil {
			*pb = &v
			return false, nil
		}
		return false, errors.New("Union does not contain bool")
	case string:
		if haveEnum {
			return false, json.Unmarshal(data, pe)
		}
		if ps != nil {
			*ps = &v
			return false, nil
		}
		return false, errors.New("Union does not contain string")
	case nil:
		if nullable {
			return false, nil
		}
		return false, errors.New("Union does not contain null")
	case json.Delim:
		if v == '{' {
			if haveObject {
				return true, json.Unmarshal(data, pc)
			}
			if haveMap {
				return false, json.Unmarshal(data, pm)
			}
			return false, errors.New("Union does not contain object")
		}
		if v == '[' {
			if haveArray {
				return false, json.Unmarshal(data, pa)
			}
			return false, errors.New("Union does not contain array")
		}
		return false, errors.New("Cannot handle delimiter")
	}
	return false, errors.New("Cannot unmarshal union")

}

func marshalUnion(pi *int64, pf *float64, pb *bool, ps *string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) ([]byte, error) {
	if pi != nil {
		return json.Marshal(*pi)
	}
	if pf != nil {
		return json.Marshal(*pf)
	}
	if pb != nil {
		return json.Marshal(*pb)
	}
	if ps != nil {
		return json.Marshal(*ps)
	}
	if haveArray {
		return json.Marshal(pa)
	}
	if haveObject {
		return json.Marshal(pc)
	}
	if haveMap {
		return json.Marshal(pm)
	}
	if haveEnum {
		return json.Marshal(pe)
	}
	if nullable {
		return json.Marshal(nil)
	}
	return nil, errors.New("Union must not be null")
}

// Code for parsing step/job with input values

type ConditionalStepClass struct {
	StepArray []Step
	MapSteps  *StepClass
}

func (x *ConditionalStepClass) UnmarshalJSON(data []byte) error {
	x.StepArray = nil
	x.MapSteps = nil

	var c StepClass
	object, err := unmarshalUnion(data, nil, nil, nil, nil, true, &x.StepArray, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}

	if object {
		x.MapSteps = &c
	}

	return nil
}

func unmarshalUnionWithMap(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool, fields []string, po *map[string]map[string]interface{}) (bool, error) {
	if pi != nil {
		*pi = nil
	}
	if pf != nil {
		*pf = nil
	}
	if pb != nil {
		*pb = nil
	}
	if ps != nil {
		*ps = nil
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.UseNumber()
	tok, err := dec.Token()
	if err != nil {
		return false, err
	}

	switch v := tok.(type) {
	case json.Number:
		if pi != nil {
			i, err := v.Int64()
			if err == nil {
				*pi = &i
				return false, nil
			}
		}
		if pf != nil {
			f, err := v.Float64()
			if err == nil {
				*pf = &f
				return false, nil
			}
			return false, errors.New("Unparsable number")
		}
		return false, errors.New("Union does not contain number")
	case float64:
		return false, errors.New("Decoder should not return float64")
	case bool:
		if pb != nil {
			*pb = &v
			return false, nil
		}
		return false, errors.New("Union does not contain bool")
	case string:
		if haveEnum {
			return false, json.Unmarshal(data, pe)
		}
		if ps != nil {
			*ps = &v
			return false, nil
		}
		return false, errors.New("Union does not contain string")
	case nil:
		if nullable {
			return false, nil
		}
		return false, errors.New("Union does not contain null")
	case json.Delim:
		if v == '{' {
			if haveObject {
				exists, err := checkObjectFieldExists(data, fields)
				if err != nil || exists {
					return true, json.Unmarshal(data, pc)
				}

				return true, json.Unmarshal(data, po)
			}
			if haveMap {
				exists, err := checkObjectFieldExists(data, fields)
				if err != nil || exists {
					return true, json.Unmarshal(data, pm)
				}

				return false, json.Unmarshal(data, po)
			}
			return false, errors.New("Union does not contain object")
		}
		if v == '[' {
			if haveArray {
				return false, json.Unmarshal(data, pa)
			}
			return false, errors.New("Union does not contain array")
		}
		return false, errors.New("Cannot handle delimiter")
	}
	return false, errors.New("Cannot unmarshal union")

}

func listFields[T any](b T) []string {
	fields := make([]string, 0)
	val := reflect.ValueOf(b)
	for i := 0; i < val.Type().NumField(); i++ {
		t := val.Type().Field(i)
		fieldName := t.Name

		switch jsonTag := t.Tag.Get("json"); jsonTag {
		case "-":
		case "":
			fields = append(fields, fieldName)
		default:
			parts := strings.Split(jsonTag, ",")
			name := parts[0]
			if name == "" {
				name = fieldName
			}
			fields = append(fields, name)
		}
	}
	return fields
}

func checkObjectFieldExists(data []byte, fields []string) (bool, error) {
	a := make(map[string]interface{})
	err := json.Unmarshal(data, &a)
	if err != nil {
		return false, err
	}

	for _, f := range fields {
		if _, ok := a[f]; ok {
			return true, nil
		}
	}
	return false, nil
}
